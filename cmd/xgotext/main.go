// Copyright (C) 2025 pi-apps-go contributors
// This file is part of Pi-Apps Go - a modern, cross-architecture/cross-platform, and modular Pi-Apps implementation in Go.
//
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.

// You should have received a copy of the GNU General Public License
// along with this program.  If not, see <https://www.gnu.org/licenses/>.

// Package main implements a custom xgotext utility that extracts translatable
// strings from custom T functions (T, Tf, Tn, Tnf, StatusT, StatusTf, etc.)
// and generates a .pot file with source references.
// This is similar to xgotext used in the original gotext library except it understands the custom T functions.
package main

import (
	"flag"
	"fmt"
	"go/ast"
	"go/parser"
	"go/token"
	"os"
	"os/exec"
	"path/filepath"
	"sort"
	"strconv"
	"strings"
	"time"
)

// TranslationEntry represents a translatable string with its source location
type TranslationEntry struct {
	MsgID       string
	MsgIDPlural string // For plural forms
	SourceFile  string
	LineNumber  int
	Function    string // Which function it came from (T, Tf, etc.)
}

// SourceLocation represents a source file location
type SourceLocation struct {
	File string
	Line int
}

// TranslationSet stores all extracted translations
type TranslationSet struct {
	entries map[string]*TranslationEntry // Key: msgid, Value: entry with first occurrence
	sources map[string][]SourceLocation  // Key: msgid, Value: list of source locations
}

func NewTranslationSet() *TranslationSet {
	return &TranslationSet{
		entries: make(map[string]*TranslationEntry),
		sources: make(map[string][]SourceLocation),
	}
}

func (ts *TranslationSet) Add(msgid, msgidPlural, sourceFile string, lineNumber int, function string) {
	key := msgid
	if msgidPlural != "" {
		key = msgid + "|" + msgidPlural
	}

	// Store first occurrence as the main entry
	if _, exists := ts.entries[key]; !exists {
		ts.entries[key] = &TranslationEntry{
			MsgID:       msgid,
			MsgIDPlural: msgidPlural,
			SourceFile:  sourceFile,
			LineNumber:  lineNumber,
			Function:    function,
		}
		ts.sources[key] = []SourceLocation{}
	}

	// Add source reference
	ts.sources[key] = append(ts.sources[key], SourceLocation{
		File: sourceFile,
		Line: lineNumber,
	})
}

// formatSources formats source references, using slim mode if requested
func formatSources(sources []SourceLocation, slimMode bool) []string {
	if !slimMode {
		// Normal mode: include line numbers
		result := make([]string, len(sources))
		for i, src := range sources {
			result[i] = fmt.Sprintf("%s:%d", src.File, src.Line)
		}
		return result
	}

	// Slim mode: group by file, only show file name if multiple references from same file
	fileCounts := make(map[string]int)
	for _, src := range sources {
		fileCounts[src.File]++
	}

	result := []string{}
	seenFiles := make(map[string]bool)

	for _, src := range sources {
		if fileCounts[src.File] > 1 && !seenFiles[src.File] {
			// Multiple references from same file - only show file name
			result = append(result, src.File)
			seenFiles[src.File] = true
		} else if fileCounts[src.File] == 1 {
			// Single reference - show file:line
			result = append(result, fmt.Sprintf("%s:%d", src.File, src.Line))
		}
	}

	return result
}

// getGitUserInfo retrieves git user name and email from git config
func getGitUserInfo() (name, email string) {
	// Try to get git user name
	if cmd := exec.Command("git", "config", "user.name"); cmd != nil {
		if output, err := cmd.Output(); err == nil {
			name = strings.TrimSpace(string(output))
		}
	}

	// Try to get git user email
	if cmd := exec.Command("git", "config", "user.email"); cmd != nil {
		if output, err := cmd.Output(); err == nil {
			email = strings.TrimSpace(string(output))
		}
	}

	// Fallback if git is not available or not configured
	if name == "" {
		name = "FULL NAME"
	}
	if email == "" {
		email = "EMAIL@ADDRESS"
	}

	return name, email
}

func (ts *TranslationSet) GeneratePOT(outputPath string, slimMode bool) error {
	file, err := os.Create(outputPath)
	if err != nil {
		return fmt.Errorf("failed to create output file: %v", err)
	}
	defer file.Close()

	// Write POT file header
	now := time.Now().Format("2006-01-02 15:04-0700")
	gitName, gitEmail := getGitUserInfo()
	fmt.Fprintf(file, `# This file was generated by the Pi-Apps Go version of xgotext.
# Copyright (C) Pi-Apps Go contributors
# This file is distributed under the same license as the Pi-Apps Go package.
# Pi-Apps Go contributors, 2025.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: pi-apps-go 1.0\n"
"Report-Msgid-Bugs-To: https://github.com/pi-apps-go/pi-apps/issues/new?template=bug-report.yml\n"
"POT-Creation-Date: %s\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: %s <%s>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: \n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=2; plural=(n != 1);\n"

`, now, gitName, gitEmail)

	// Sort entries by source file and line number for consistent output
	type entryWithKey struct {
		key   string
		entry *TranslationEntry
	}
	entries := make([]entryWithKey, 0, len(ts.entries))
	for key, entry := range ts.entries {
		entries = append(entries, entryWithKey{key: key, entry: entry})
	}

	sort.Slice(entries, func(i, j int) bool {
		if entries[i].entry.SourceFile != entries[j].entry.SourceFile {
			return entries[i].entry.SourceFile < entries[j].entry.SourceFile
		}
		return entries[i].entry.LineNumber < entries[j].entry.LineNumber
	})

	// Write each translation entry
	for _, e := range entries {
		entry := e.entry
		sources := ts.sources[e.key]

		// Write source references (formatted according to mode)
		formattedSources := formatSources(sources, slimMode)
		for _, source := range formattedSources {
			fmt.Fprintf(file, "#: %s\n", source)
		}

		// Write function name as comment
		fmt.Fprintf(file, "#. Function: %s\n", entry.Function)

		// Write msgid
		fmt.Fprintf(file, "msgid ")
		writeStringLiteral(file, entry.MsgID)
		fmt.Fprintf(file, "\n")

		// Write msgid_plural if present
		if entry.MsgIDPlural != "" {
			fmt.Fprintf(file, "msgid_plural ")
			writeStringLiteral(file, entry.MsgIDPlural)
			fmt.Fprintf(file, "\n")
			fmt.Fprintf(file, "msgstr[0] \"\"\n")
			fmt.Fprintf(file, "msgstr[1] \"\"\n")
		} else {
			fmt.Fprintf(file, "msgstr \"\"\n")
		}

		fmt.Fprintf(file, "\n")
	}

	return nil
}

func (ts *TranslationSet) GeneratePO(outputPath, locale string, slimMode bool) error {
	file, err := os.Create(outputPath)
	if err != nil {
		return fmt.Errorf("failed to create output file: %v", err)
	}
	defer file.Close()

	// Write PO file header
	now := time.Now().Format("2006-01-02 15:04-0700")
	gitName, gitEmail := getGitUserInfo()
	fmt.Fprintf(file, `# This file was generated by the Pi-Apps Go version of xgotext.
# Copyright (C) Pi-Apps Go contributors
# This file is distributed under the same license as the Pi-Apps Go package.
# Pi-Apps Go contributors, 2025.
#
msgid ""
msgstr ""
"Project-Id-Version: pi-apps-go 1.0\n"
"Report-Msgid-Bugs-To: https://github.com/pi-apps-go/pi-apps/issues/new?template=bug-report.yml\n"
"POT-Creation-Date: %s\n"
"PO-Revision-Date: %s\n"
"Last-Translator: %s <%s>\n"
"Language-Team: English <en@li.org>\n"
"Language: %s\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=2; plural=(n != 1);\n"

`, now, now, gitName, gitEmail, locale)

	// Sort entries by source file and line number for consistent output
	type entryWithKey struct {
		key   string
		entry *TranslationEntry
	}
	entries := make([]entryWithKey, 0, len(ts.entries))
	for key, entry := range ts.entries {
		entries = append(entries, entryWithKey{key: key, entry: entry})
	}

	sort.Slice(entries, func(i, j int) bool {
		if entries[i].entry.SourceFile != entries[j].entry.SourceFile {
			return entries[i].entry.SourceFile < entries[j].entry.SourceFile
		}
		return entries[i].entry.LineNumber < entries[j].entry.LineNumber
	})

	// Write each translation entry with English translations (msgstr = msgid)
	for _, e := range entries {
		entry := e.entry
		sources := ts.sources[e.key]

		// Write source references (formatted according to mode)
		formattedSources := formatSources(sources, slimMode)
		for _, source := range formattedSources {
			fmt.Fprintf(file, "#: %s\n", source)
		}

		// Write function name as comment
		fmt.Fprintf(file, "#. Function: %s\n", entry.Function)

		// Write msgid
		fmt.Fprintf(file, "msgid ")
		writeStringLiteral(file, entry.MsgID)
		fmt.Fprintf(file, "\n")

		// Write msgid_plural if present
		if entry.MsgIDPlural != "" {
			fmt.Fprintf(file, "msgid_plural ")
			writeStringLiteral(file, entry.MsgIDPlural)
			fmt.Fprintf(file, "\n")
			// For English, msgstr[0] = msgid (singular), msgstr[1] = msgid_plural
			fmt.Fprintf(file, "msgstr[0] ")
			writeStringLiteral(file, entry.MsgID)
			fmt.Fprintf(file, "\n")
			fmt.Fprintf(file, "msgstr[1] ")
			writeStringLiteral(file, entry.MsgIDPlural)
			fmt.Fprintf(file, "\n")
		} else {
			// For English, msgstr = msgid (no translation needed)
			fmt.Fprintf(file, "msgstr ")
			writeStringLiteral(file, entry.MsgID)
			fmt.Fprintf(file, "\n")
		}

		fmt.Fprintf(file, "\n")
	}

	return nil
}

func writeStringLiteral(file *os.File, s string) {
	// First, escape special characters for .pot format
	// We need to escape in the right order to avoid double-escaping
	var escaped strings.Builder
	for _, r := range s {
		switch r {
		case '\\':
			escaped.WriteString("\\\\")
		case '"':
			escaped.WriteString("\\\"")
		case '\n':
			escaped.WriteString("\\n")
		case '\t':
			escaped.WriteString("\\t")
		case '\r':
			escaped.WriteString("\\r")
		default:
			escaped.WriteRune(r)
		}
	}
	escapedStr := escaped.String()

	// Write as a quoted string, handling long strings
	// In GNU gettext format, strings can span multiple lines by starting each
	// continuation line with a quote. We must not split in the middle of escape sequences.
	const maxLineLength = 70 // Max length per line in .pot format

	if len(escapedStr) <= maxLineLength {
		fmt.Fprintf(file, "\"%s\"", escapedStr)
	} else {
		// Split long strings across multiple lines
		// Each line should be at most maxLineLength characters
		// Lines are continued by starting the next line with a quote
		// We must ensure we don't split in the middle of escape sequences
		fmt.Fprintf(file, "\"")
		remaining := escapedStr

		for len(remaining) > maxLineLength {
			// Find a safe split point - don't split right after a backslash
			// (which would break escape sequences like \n, \t, etc.)
			splitPos := maxLineLength
			if splitPos < len(remaining) && remaining[splitPos-1] == '\\' {
				// If we'd split right after a backslash, move the split point back
				splitPos--
			}

			// Write up to splitPos characters
			line := remaining[:splitPos]
			remaining = remaining[splitPos:]
			fmt.Fprintf(file, "%s\"\n\"", line)
		}

		// Write the remaining part
		if len(remaining) > 0 {
			fmt.Fprintf(file, "%s", remaining)
		}
		fmt.Fprintf(file, "\"")
	}
}

// Custom T functions to look for
var translationFunctions = map[string]bool{
	"T":            true,
	"Tf":           true,
	"Tn":           true,
	"Tnf":          true,
	"StatusT":      true,
	"StatusTf":     true,
	"StatusGreenT": true,
	"ErrorT":       true,
	"ErrorNoExitT": true,
	"WarningT":     true,
	"DebugT":       true,
	"DebugTf":      true,
}

// Packages that contain T functions
var translationPackages = map[string]bool{
	"api":      true,
	"settings": true,
}

func isTranslationCall(expr ast.Expr, currentPackage string) (pkgName, funcName string, ok bool) {
	switch x := expr.(type) {
	case *ast.CallExpr:
		return isTranslationCall(x.Fun, currentPackage)
	case *ast.SelectorExpr:
		if ident, ok := x.X.(*ast.Ident); ok {
			pkgName := ident.Name
			if translationPackages[pkgName] && translationFunctions[x.Sel.Name] {
				return pkgName, x.Sel.Name, true
			}
		}
	case *ast.Ident:
		// Handle unqualified function calls (e.g., T() instead of api.T())
		// Check if it's a translation function and we're in a translation package
		if translationFunctions[x.Name] && translationPackages[currentPackage] {
			return currentPackage, x.Name, true
		}
	}
	return "", "", false
}

func extractStringFromExpr(expr ast.Expr) (string, bool) {
	switch x := expr.(type) {
	case *ast.BasicLit:
		if x.Kind == token.STRING {
			// Use strconv.Unquote to properly handle Go string literals
			// This handles both "..." and `...` strings and all escape sequences
			s, err := strconv.Unquote(x.Value)
			if err != nil {
				return "", false
			}
			return s, true
		}
	case *ast.BinaryExpr:
		// Handle string concatenation across lines: "a" + "b"
		if x.Op == token.ADD {
			left, lok := extractStringFromExpr(x.X)
			right, rok := extractStringFromExpr(x.Y)
			if lok && rok {
				return left + right, true
			}
		}
	case *ast.ParenExpr:
		// Parenthesized expression
		return extractStringFromExpr(x.X)
	}
	return "", false
}

func extractTranslationFromCall(call *ast.CallExpr, fset *token.FileSet, sourceFile string, currentPackage string) (msgid, msgidPlural string, function string, ok bool) {
	pkgName, funcName, ok := isTranslationCall(call.Fun, currentPackage)
	if !ok {
		return "", "", "", false
	}

	function = pkgName + "." + funcName

	switch funcName {
	case "T":
		// T(msgid string)
		if len(call.Args) >= 1 {
			if msgid, ok := extractStringFromExpr(call.Args[0]); ok {
				return msgid, "", function, true
			}
		}
	case "Tf":
		// Tf(format string, args ...interface{})
		if len(call.Args) >= 1 {
			if msgid, ok := extractStringFromExpr(call.Args[0]); ok {
				return msgid, "", function, true
			}
		}
	case "Tn":
		// Tn(msgid, msgidPlural string, n int)
		if len(call.Args) >= 2 {
			msgid, _ := extractStringFromExpr(call.Args[0])
			msgidPlural, _ := extractStringFromExpr(call.Args[1])
			if msgid != "" {
				return msgid, msgidPlural, function, true
			}
		}
	case "Tnf":
		// Tnf(msgid, msgidPlural string, n int, args ...interface{})
		if len(call.Args) >= 2 {
			msgid, _ := extractStringFromExpr(call.Args[0])
			msgidPlural, _ := extractStringFromExpr(call.Args[1])
			if msgid != "" {
				return msgid, msgidPlural, function, true
			}
		}
	case "StatusT", "StatusTf", "StatusGreenT", "ErrorT", "ErrorNoExitT", "WarningT":
		// StatusT(msgid string, args ...interface{})
		// These can take a string directly or a T() call
		if len(call.Args) >= 1 {
			// Check if first arg is a T() call
			if nestedCall, ok := call.Args[0].(*ast.CallExpr); ok {
				if _, nestedFunc, ok := isTranslationCall(nestedCall, currentPackage); ok {
					if nestedFunc == "T" || nestedFunc == "Tf" {
						if len(nestedCall.Args) >= 1 {
							if msgid, ok := extractStringFromExpr(nestedCall.Args[0]); ok {
								return msgid, "", function, true
							}
						}
					}
				}
			}
			// Or it might be a direct string
			if msgid, ok := extractStringFromExpr(call.Args[0]); ok {
				return msgid, "", function, true
			}
		}
	case "DebugT", "DebugTf":
		// DebugT(msg string) or DebugTf(format string, args ...interface{})
		if len(call.Args) >= 1 {
			if msgid, ok := extractStringFromExpr(call.Args[0]); ok {
				return msgid, "", function, true
			}
		}
	}

	return "", "", "", false
}

func processFile(filePath string, ts *TranslationSet) error {
	fset := token.NewFileSet()
	node, err := parser.ParseFile(fset, filePath, nil, parser.ParseComments)
	if err != nil {
		return fmt.Errorf("failed to parse file %s: %v", filePath, err)
	}

	// Get relative path for source reference
	relPath, err := filepath.Rel(".", filePath)
	if err != nil {
		relPath = filePath
	}

	// Get the package name from the AST
	currentPackage := ""
	if node.Name != nil {
		currentPackage = node.Name.Name
	}

	// Walk the AST
	ast.Inspect(node, func(n ast.Node) bool {
		if call, ok := n.(*ast.CallExpr); ok {
			msgid, msgidPlural, function, ok := extractTranslationFromCall(call, fset, relPath, currentPackage)
			if ok {
				pos := fset.Position(call.Pos())
				ts.Add(msgid, msgidPlural, relPath, pos.Line, function)
			}
		}
		return true
	})

	return nil
}

func main() {
	var (
		outputPath = flag.String("o", "messages.pot", "Output .pot file path")
		poPath     = flag.String("po", "", "Output .po file path for English translations (optional)")
		locale     = flag.String("locale", "en_US", "Locale code for the .po file (default: en_US)")
		directory  = flag.String("d", ".", "Directory to scan for Go files")
		slimMode   = flag.Bool("slim", false, "Slim mode: only show file name (not line numbers) when same string appears multiple times in the same file")
	)
	flag.Parse()

	ts := NewTranslationSet()

	// Walk directory and process all .go files
	err := filepath.Walk(*directory, func(path string, info os.FileInfo, err error) error {
		if err != nil {
			return err
		}

		// Skip vendor, test files, and non-Go files
		if info.IsDir() {
			if info.Name() == "vendor" || info.Name() == ".git" || info.Name() == "bin" {
				return filepath.SkipDir
			}
			return nil
		}

		if !strings.HasSuffix(path, ".go") {
			return nil
		}

		// Skip test files
		if strings.HasSuffix(path, "_test.go") {
			return nil
		}

		// Skip the xgotext tool itself
		if strings.Contains(path, "cmd/xgotext") {
			return nil
		}

		return processFile(path, ts)
	})

	if err != nil {
		fmt.Fprintf(os.Stderr, "Error processing files: %v\n", err)
		os.Exit(1)
	}

	// Generate .pot file
	if err := ts.GeneratePOT(*outputPath, *slimMode); err != nil {
		fmt.Fprintf(os.Stderr, "Error generating .pot file: %v\n", err)
		os.Exit(1)
	}

	fmt.Printf("Successfully extracted %d translatable strings to %s\n", len(ts.entries), *outputPath)

	// Generate .po file if requested
	if *poPath != "" {
		if err := ts.GeneratePO(*poPath, *locale, *slimMode); err != nil {
			fmt.Fprintf(os.Stderr, "Error generating .po file: %v\n", err)
			os.Exit(1)
		}
		fmt.Printf("Successfully generated English translations to %s\n", *poPath)
	}
}
